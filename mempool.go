package main

import (

    "bytes"
    "fmt"
    "log"
    "net/http"
    "os"
    "encoding/JSON"
	"encoding/csv"
	"strconv"
	"time"
)

// One fee in the JSON response
type AutoGenerated struct {
	Data []struct {
		FeeTx struct {
			BeforeLastBlock json.Number `json:"before_last_block"`
			Conflicts json.Number `json:"conflicts"`
			SinceLastBlock json.Number `json:"since_last_block"`
		} `json:"fee_tx"`
		NTx struct {
			BeforeLastBlock json.Number `json:"before_last_block"`
			Conflicts json.Number `json:"conflicts"`
			SinceLastBlock json.Number `json:"since_last_block"`
		} `json:"n_tx"`
		SizeTx struct {
			BeforeLastBlock json.Number `json:"before_last_block"`
			Conflicts json.Number `json:"conflicts"`
			SinceLastBlock json.Number `json:"since_last_block"`
		} `json:"size_tx"`
		Time json.Number `json:"time"`
		TxesPerMinute json.Number `json:"txes_per_minute"`
		VolTx struct {
			BeforeLastBlock json.Number `json:"before_last_block"`
			Conflicts json.Number `json:"conflicts"`
			SinceLastBlock json.Number `json:"since_last_block"`
		} `json:"vol_tx"`
	} `json:"data"`
}


func main() {


	makefile := namer()
	xx := makefile.String()
	file, err :=os.Create(xx)
	if err != nil{
		fmt.Println("Cannot create csv")
	}

	defer file.Close()

	fmt.Println("Hold on...")
	
//http query
	i:=0
	for ;i <= 0; i++ {
		response, err := http.Get("https://tradeblock.com/api/blockchain/mempoolrecent/168/600")
		if err != nil {
			fmt.Println("error retrieving data from Tradeblock")
		}
		defer response.Body.Close()

//decoder
		dec := json.NewDecoder(response.Body)
		fees := AutoGenerated{}
		err = dec.Decode(&fees)
			if err != nil {
			log.Fatal("Failed to decode the JSON body:", err)
  			}
		fmt.Printf("decoded\n")



			csvwr := csv.NewWriter(file)
			headers := []string{"Unix time epoch", "Pool fees since last block", "Pool fees before last", "Txs since last",
				"Txs before last", "Bytes since last", "Bytes before last", "txs per minute", "timestamp"}
			csvwr.Write(headers)
			if err := csvwr.Error(); err != nil {
				log.Fatalln("error writing csv:", err)
			}
			fmt.Println("ttt")
			defer file.Close()
		var counter int = 1

		for _, fee := range fees.Data {


			eqAa := "=(A"
			datecol2 := string("/24/60/60)+DATE(1970,1,1)")


			ftime := fee.Time.String()
			feebfr := fee.FeeTx.BeforeLastBlock.String()
			feesnc := fee.FeeTx.SinceLastBlock.String()
			qtybfr := fee.NTx.BeforeLastBlock.String()
			qtysnc := fee.NTx.SinceLastBlock.String()
			datbfr := fee.SizeTx.BeforeLastBlock.String()
			datsnc := fee.SizeTx.SinceLastBlock.String()
			txpmin := fee.TxesPerMinute.String()

			counter = counter + 1
			record := []string{ftime, feesnc, feebfr, qtysnc, qtybfr, datsnc, datbfr, txpmin, eqAa + strconv.Itoa(counter) + datecol2}
			csvwr.Flush()
			csvwr.Write(record)
			if err := csvwr.Error(); err != nil {
				log.Fatalf("Could not write to CSV file:", err)
			}
		}
		fmt.Println("success!")
		time.Sleep(time.Second * 1 )
		fmt.Println("closing...")
		time.Sleep(time.Second *1)
	  }

}

func namer()(bytes.Buffer) {
	hour, min := time.Now().Hour(), time.Now().Minute()
	_, month, day := time.Now().Date()
	h := strconv.Itoa(hour)
	n := strconv.Itoa(min)
	d := strconv.Itoa(day)
	m := strconv.Itoa(int(month))
	var huffer bytes.Buffer
	huffer.WriteString("MEMPL TBK")
	huffer.WriteString(m)
	huffer.WriteString("-")
	huffer.WriteString(d)
	huffer.WriteString("at")
	huffer.WriteString(h)
	huffer.WriteString(n)
	huffer.WriteString(".csv")

	return huffer
}





